{-# LANGUAGE CPP #-}
-- -*-haskell-*-
--  GIMP Toolkit (GTK) Extended Input Devices
--
--  Author : Casey McCann
--
--  Created: 27 Mar 2013
--
--  Copyright (C) 2013 Casey McCann
--
--  This library is free software; you can redistribute it and/or
--  modify it under the terms of the GNU Lesser General Public
--  License as published by the Free Software Foundation; either
--  version 2.1 of the License, or (at your option) any later version.
--
--  This library is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--  Lesser General Public License for more details.
--
-- |
-- Maintainer  : gtk2hs-users@lists.sourceforge.net
-- Stability   : provisional
-- Portability : portable (depends on GHC)
--
-- Functions for handling extended input devices
--
--
module Graphics.UI.Gtk.Gdk.InputDevice (

-- * Detail
--
-- | In addition to the normal keyboard and mouse input devices, GTK+ also 
-- contains support for /extended input devices/. In particular, this support 
-- is targeted at graphics tablets. Graphics tablets typically return 
-- sub-pixel positioning information and possibly information about the 
-- pressure and tilt of the stylus. Under X, the support for extended devices 
-- is done through the /XInput/ extension.
--
-- Because handling extended input devices may involve considerable overhead, 
-- they need to be turned on for each 'DrawWindow' individually using 
-- 'inputSetExtensionEvents'. (Or, more typically, for GtkWidgets, using 
-- 'widgetSetExtensionEvents'. As an additional complication, depending on the 
-- support from the windowing system, it's possible that a normal mouse cursor 
-- will not be displayed for a particular extension device. If an application 
-- does not want to deal with displaying a cursor itself, it can ask only to 
-- get extension events from devices that will display a cursor, by passing the 
-- 'ExtensionEventsCursor' value to 'inputSetExtensionEvents'. Otherwise, the 
-- application must retrieve the device information using 'devicesList', use
-- 'deviceHasCursor' to check the flag on the device, and, if it is 'False', 
-- draw a cursor itself when it receives motion events.
--
-- Each pointing device is assigned a unique integer ID; the particular device 
-- that generated an event can be found using 'eventDevice'. The events 
-- generated by pointer devices have also been extended to contain pressure and
-- tilt values reported by the device. The pressure is a a 'Double' value 
-- ranging from 0.0 to 1.0, while the tilt is given by 'Double' values for each
-- axis, ranging from -1.0 to 1.0. (With -1.0 representing the maximum tilt to 
-- the left or up, and 1.0 representing the maximum tilt to the right or down.)
--
-- One additional value in each event is an 'InputSource' value indicating the 
-- type of device. This field is present to allow simple applications to (for 
-- instance) delete when they detect eraser devices without having to keep 
-- track of complicated per-device settings.
--
-- Various aspects of each device may be configured. The easiest way of 
-- creating a GUI to allow the user to configure such a device is to use the 
-- 'InputDialog' widget in GTK+. However, even when using this widget, 
-- application writers will need to directly query and set the configuration 
-- parameters in order to save the state between invocations of the 
-- application. The configuration of devices is queried using 'devicesList'. 
-- Each device must be activated using 'deviceSetMode', which also controls 
-- whether the device's range is mapped to the entire screen or to a single 
-- window. The mapping of the valuators of the device onto the predefined 
-- valuator types is set using 'deviceSetAxisUse', and the source type for each 
-- device can be set with 'deviceSetSource'.
--
-- Devices may also have associated keys or macro buttons. Such keys can be 
-- globally set to map into normal X keyboard events. The mapping is set using 
-- 'deviceSetKey'.
--
-- The interfaces in this section will most likely be considerably modified in 
-- the future to accomodate devices that may have different sets of additional 
-- valuators than the pressure and tilt.


#if GTK_CHECK_VERSION(2,2,0)
-- * Types
  Device,
  InputSource(..),
  InputMode(..),
  AxisUse(..),
  
#if GTK_MAJOR_VERSION < 3
  ExtensionMode(..),
  DeviceAxis(..),
#endif

-- * Methods
  devicesList,
  deviceName,
  deviceSource,
  deviceInputMode,
  deviceHasCursor,
  
#if GTK_MAJOR_VERSION < 3
  deviceAxes,
  deviceSetSource,
  inputSetExtensionEvents,
#endif

  deviceSetMode,
  deviceSetKey,
  deviceSetAxisUse
#endif
  ) where

import Control.Monad	(liftM)
import Control.Monad.Reader	(ReaderT(..), ask)

import System.Glib.FFI
import System.Glib.Flags (fromFlags)
import System.Glib.Attributes
import System.Glib.Properties
import System.Glib.GList
import System.Glib.GObject		(constructNewGObject, makeNewGObject)
import Graphics.UI.Gtk.Gdk.Keys (KeyVal)
{#import Graphics.UI.Gtk.Types#}
{#import Graphics.UI.Gtk.Signals#}
{#import Graphics.UI.Gtk.Gdk.Enums#}
#if GTK_MAJOR_VERSION < 3 
import Graphics.UI.Gtk.General.Structs (DeviceAxis(..))
#endif


{# context lib="gdk" prefix="gdk" #}

#if GTK_CHECK_VERSION(2,2,0)

-- | An enumeration describing the type of an input device in general terms.
--   The core pointer will be reported as 'SourceMouse', even if it is something
--   else, such as a trackball. 'SourcePen' indicates a tablet stylus or similar
--   devices, and 'SourceEraser' is typically the other end of a two-sided stylus.
--   'SourceCursor' indicates a tablet \"puck\" or similar device.
{#enum GdkInputSource as InputSource {underscoreToCase} deriving (Bounded,Eq,Show)#}

-- | An enumeration that describes what the coordinate space of an extended
--   input device is mapped to. With 'ModeWindow' the exact choice of mapping
--   is undefined, but will typically be the same way in which the focus window 
--   for key events is determined.
{#enum GdkInputMode as InputMode {underscoreToCase} deriving (Bounded,Eq,Show)#}


--------------------
-- Methods

#if GTK_MAJOR_VERSION < 3

-- | Returns the list of available input devices for the default display.
devicesList :: IO [Device]
devicesList = 
  {# call gdk_devices_list #}
  >>= readGList
  >>= mapM (makeNewGObject mkDevice . return)


-- | Returns the core pointer device for the default display.
deviceGetCorePointer :: IO Device
deviceGetCorePointer =  makeNewGObject mkDevice ( {# call gdk_device_get_core_pointer #} )

#else

{#enum GdkDeviceType as DeviceType {underscoreToCase} deriving (Bounded,Eq,Show)#}

-- | Returns the list of available input devices for the default display.
devicesList :: IO [Device]
devicesList = do
  dsp <- maybeNull (makeNewGObject mkDisplay) ({# call gdk_display_get_default #})
  case dsp of
      Nothing -> return []
      Just d  -> do
        dvMgr <- {# call gdk_display_get_device_manager #} d
        mDevs <- readGList =<< (({# call gdk_device_manager_list_devices #}) dvMgr 
                                    (fromIntegral $ fromEnum DeviceTypeMaster))
        sDevs <- readGList =<< (({# call gdk_device_manager_list_devices #}) dvMgr
                                    (fromIntegral $ fromEnum DeviceTypeSlave))
        mapM (makeNewGObject mkDevice . return) (mDevs ++ sDevs)

#endif

#if GTK_MAJOR_VERSION < 3
-- | Sets the source type for an input device.
deviceSetSource :: Device -> InputSource -> IO ()
deviceSetSource dev src =
  {# call gdk_device_set_source #} dev (fromIntegral (fromEnum src))
#endif

-- | Sets a the mode of an input device. The mode controls if the device is 
--   active and whether the device's range is mapped to the entire screen or to 
--   a single window. Returns 'True' if the mode was successfully changed.
deviceSetMode :: Device -> InputMode -> IO Bool
deviceSetMode dev mode = liftM toBool $
  {# call gdk_device_set_mode #} dev (fromIntegral (fromEnum mode))

-- | Specifies the X key event to generate when a macro button of a device is pressed.
deviceSetKey :: Device      -- ^ An extended input device
             -> Int         -- ^ The index of the macro button to set
             -> KeyVal      -- ^ The keyval to generate
             -> [Modifier]  -- ^ The 'Modifier's to set.
             -> IO ()
deviceSetKey dev ix kv mods =
  {# call gdk_device_set_key #} dev (fromIntegral ix) (fromIntegral kv) (fromIntegral (fromFlags mods))

-- | Specifies how an axis of a device is used.
deviceSetAxisUse :: Device    -- ^ An extended input device
                 -> Int       -- ^ The index of the axis to set
                 -> AxisUse   -- ^ How the axis should be used
                 -> IO ()
deviceSetAxisUse dev ix ax =
  {# call gdk_device_set_axis_use #} dev (fromIntegral ix) (fromIntegral (fromEnum ax))


#if GTK_MAJOR_VERSION < 3

-- | Gets the name of a 'Device'.
deviceName :: Device -> IO String
deviceName (Device dev) = peekCString =<< withForeignPtr dev ( {# get Device->name #} )

-- | Gets the 'InputSource' assigned to a 'Device'.
deviceSource :: Device -> IO InputSource
deviceSource (Device dev) = liftM (toEnum . fromIntegral) 
                          . withForeignPtr dev $ {# get Device->source #}

-- | Gets the 'InputMode' assigned to a 'Device'.
deviceInputMode :: Device -> IO InputMode
deviceInputMode (Device dev) = liftM (toEnum . fromIntegral) 
                             . withForeignPtr dev $ {# get Device->mode #}

-- | Checks whether this device displays a mouse cursor automatically.
deviceHasCursor :: Device -> IO Bool
deviceHasCursor (Device dev) = liftM toBool 
                             . withForeignPtr dev $ {# get Device->has_cursor #}

-- | A collection of 'DeviceAxis' values describing the axes of this device.
deviceAxes :: Device -> IO [DeviceAxis]
deviceAxes (Device dev) = do
    num_axes <- fromIntegral `liftM` withForeignPtr dev ({# get Device->num_axes #})
    axesPtr <- withForeignPtr dev ({# get Device->axes #})
    peekArray (fromIntegral num_axes) (castPtr axesPtr)

#else

--  | Gets the name of a 'Device'.
deviceName :: Device -> IO String
deviceName dev = peekCString =<< ({# call gdk_device_get_name #} dev)
--  deviceName (Device dev) = peekCString =<< withForeignPtr dev ({# call gdk_device_get_name #})

--  | Gets the 'InputSource' assigned to a 'Device'.
deviceSource :: Device -> IO InputSource
deviceSource dev = liftM (toEnum . fromIntegral) $ {# call gdk_device_get_source #} dev
--  deviceSource (Device dev) = liftM (toEnum . fromIntegral) 
                          --  . withForeignPtr dev $ ({# call gdk_device_get_source #})

--  | Gets the 'InputMode' assigned to a 'Device'.
deviceInputMode :: Device -> IO InputMode
deviceInputMode dev = liftM (toEnum . fromIntegral) $ {# call gdk_device_get_mode #} dev
--  deviceInputMode (Device dev) = liftM (toEnum . fromIntegral) 
                             --  . withForeignPtr dev $ ({# call gdk_device_get_mode #})

--  | Checks whether this device displays a mouse cursor automatically.
deviceHasCursor :: Device -> IO Bool
deviceHasCursor d@(Device dev) = liftM toBool $ {# call gdk_device_get_has_cursor #} d
                             --  . withForeignPtr (dev :: ForeignPtr Device) 
                             --  $ \ptr -> ({# call gdk_device_get_has_cursor #}) (ptr :: Ptr Device)

#endif

#if GTK_MAJOR_VERSION < 3

-- | Turns extension events on or off for a particular window, and specifies the event mask for extension events.
inputSetExtensionEvents :: DrawWindow -> Int -> ExtensionMode -> IO ()
inputSetExtensionEvents wnd msk exmode =
  {# call gdk_input_set_extension_events #} wnd (fromIntegral msk) (fromIntegral (fromEnum exmode))

#endif

#endif